"""
import os
from pprint import pprint

path = '.'
data = {}
for root, dirs, files in os.walk(path):
    for filename in files:
        fullname = os.path.join(root, filename)
        key = (os.path.getsize(fullname), filename)
        data.update({key: fullname})

pprint(data)


Функция eval() полезна, когда необходимо выполнить динамически обновляемое
выражение Python из какого-либо ввода (например, функции input()), представленного
в виде строки или объекта байт-кода. Это невероятно полезный инструмент,
но то, что она может выполнять программный код, имеет важные последствия для безопасности,
которые следует учесть перед ее применением.

Вы можете использовать встроеннyю функцию eval() для динамического исполнения выражений
из ввода на основе строки или скомпилированного кода. Если вы передаете в eval() строку,
то функция анализирует ее, компилирует в байт-код и выполняет как выражение Python.

Для динамического выполнения кода можно также использовать функцию exec().
Основное различие между eval() и exec() состоит в том, что eval() может выполнять лишь выражения,
тогда как функции exec() можно «скормить» любой фрагмент кода Python.

eval("2 ** 8")
eval("1024 + 1024")
eval("sum([8, 16, 32])")

x = 100
eval("x * 2")


eval("if x: print(x)")

в eval() нельзя передать конструкции c if, import, def или class, с циклами for и while.
Однако ключевое слово for может использоваться в eval() в случае выражений для генераторов списков.

eval("pi = 3.1416")
В eval() запрещены и операции присваивания


y = 200
x = 100
eval("x + y", {"x": x})
Аргумент globals опционален. Он содержит словарь, обеспечивающий доступ eval() к глобальному пространству имен.
С помощью глобальных переменных можно указать eval(), какие глобальные имена использовать при выполнении выражения.

x = 100
eval("x + y", {}, {"x": 100})
Аргумент locals также является необязательным аргументом. В этом случае словарь содержит переменные,
которые eval() использует в качестве локальных имен при оценке выражения.
"""

import re
from uuid import UUID
pattern = "^[\da-f]{8}-([\da-f]{4}-){3}[\da-f]{12}$"
i = '20f5484b-88ae-49b0-8af0-3a389b4917dd'
re.match(pattern, i)
print(UUID(i))
