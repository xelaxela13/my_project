# def search(_list, e):
#     for i in range(len(_list)):
#         if _list[i] == e:
#             return i
#     return

"""
Сортировка пузырьком

это метод сортировки массивов и списков путем последовательного сравнения и обмена соседних элементов,
если предшествующий оказывается больше последующего.

В процессе выполнения данного алгоритма элементы с большими значениями оказываются в конце списка,
а элементы с меньшими значениями постепенно перемещаются по направлению к началу списка. Образно говоря,
тяжелые элементы падают на дно, а легкие медленно всплывают подобно пузырькам воздуха.

В сортировке методом пузырька количество итераций внешнего цикла определяется длинной списка минус единица,
так как когда второй элемент становится на свое место, то первый уже однозначно минимальный и находится на своем месте.

Количество итераций внутреннего цикла зависит от номера итерации внешнего цикла, т
ак как конец списка уже отсортирован, и выполнять проход по этим элементам смысла нет.

Пусть имеется список [6, 12, 4, 3, 8].

За первую итерацию внешнего цикла число 12 переместится в конец.
Для этого потребуется 4 сравнения во внутреннем цикле:

6 > 12? Нет
12 > 4? Да. Меняем местами
12 > 3? Да. Меняем местами
12 > 8? Да. Меняем местами
Результат: [6, 4, 3, 8, 12]

За вторую итерацию внешнего цикла число 8 переместиться на предпоследнее место.
Для этого потребуется 3 сравнения:

6 > 4? Да. Меняем местами
6 > 3? Да. Меняем местами
6 > 8? Нет
Результат: [4, 3, 6, 8, 12]

На третьей итерации внешнего цикла исключаются два последних элемента.
Количество итераций внутреннего цикла равно двум:

4 > 3? Да. Меняем местами
4 > 6? Нет
Результат: [3, 4, 6, 8, 12]

На четвертой итерации внешнего цикла осталось сравнить только первые два элемента,
поэтому количество итераций внутреннего равно единице:

3 > 4? Нет
Результат: [3, 4, 6, 8, 12]

from random import randint

n = 10
a = [randint(1, 99) for i in range(100)]
print(a)


for i in range(n-1):
    for j in range(n-i-1):
        if a[j] > a[j+1]:
            a[j], a[j+1] = a[j+1], a[j]

print(a)


from random import randint

n = 10
a = [randint(1, 99) for i in range(n)]
print(a)

i = 0
while i < n - 1:
    j = 0
    while j < n - 1 - i:
        if a[j] > a[j+1]:
            a[j], a[j+1] = a[j+1], a[j]
        j += 1
    i += 1

print(a)

from random import randint

def bubble(array):
    for i in range(n-1):
        for j in range(n-i-1):
            if array[j] > array[j+1]:
                buff = array[j]
                array[j] = array[j+1]
                array[j+1] = buff

n = 10
a = [randint(1, 99) for i in range(n)]

print(a)
bubble(a)
print(a)
"""

"""
Сортировка выбором

Алгоритм сортировки выбором заключается в поиске на необработанном срезе массива 
или списка минимального значения 
и в дальнейшем обмене этого значения с первым элементом необработанного среза. 
На следующем шаге необработанный срез уменьшается на один элемент.

Найти наименьшее значение в списке.
Записать его в начало списка, а первый элемент - на место, где раньше стоял наименьший.
Снова найти наименьший элемент в списке. При этом в поиске не участвует первый элемент.
Второй минимум поместить на второе место списка. Второй элемент при этом перемещается на освободившееся место.
Продолжать выполнять поиcк и обмен, пока не будет достигнут конец списка.

# Заполняем список из 10 элементов
# случайными числами от 1 до 99 и
# выводим неотсортированный список на экран.
from random import randint
n = 10
arr = [randint(1, 99) for i in range(n)]
print(arr)
 
 
def choose_sort(arr, n):
    print(arr)

    # В цикле переменная i хранит индекс ячейки,
    # в которую записывается минимальный элемент.
    # Сначала это будет первая ячейка.
    i = 0

    # n - 1, так как последний элемент
    # обменивать уже не надо.
    while i < n - 1:

        # ПОИСК МИНИМУМА
        # Сначала надо найти минимальное значение
        # на срезе от i до конца списка.
        # Переменная m будет хранить индекс ячейки
        # с минимальным значением.
        # Сначала предполагаем, что
        # в ячейке i содержится минимальный элемент.
        m = i
        # Поиск начинаем с ячейки следующей за i.
        j = i + 1
        # Пока не дойдем конца списка,
        while j < n:
            # будем сравнивать значение ячейки j,
            # со значением ячейки m.
            if arr[j] < arr[m]:
                # Если в j значение меньше, чем в m,
                # сохраним в m номер найденного
                # на данный момент минимума.
                m = j
            # Перейдем к следующей ячейке.
            j += 1

        # ОБМЕН ЗНАЧЕНИЙ
        # В ячейку i записывается найденный минимум,
        # а значение из ячейки i переносится
        # на старое место минимума.
        arr[i], arr[m] = arr[m], arr[i]

        # ПЕРЕХОД К СЛЕДУЮЩЕЙ НЕОБРАБОТАННОЙ ЯЧЕЙКЕ
        i += 1
    return arr
"""

"""
Общая суть сортировок вставками такова:

Перебираются элементы в неотсортированной части массива.
Каждый элемент вставляется в отсортированную часть массива на то место, где он должен находиться.

Это, в принципе, всё, что Вам нужно знать про сортировки вставками. 
То есть, сортировки вставками всегда делят массив на 2 части — отсортированную и неотсортированную. 
Из неотсортированной части извлекается любой элемент. Поскольку другая часть массива отсортирована, 
то в ней достаточно быстро можно найти своё место для этого извлечённого элемента. Элемент вставляется куда нужно, 
в результате чего отсортированная часть массива увеличивается, а неотсортированная уменьшается. 
Всё. По такому принципу работают все сортировки вставками. 

Самое слабое место в этом подходе — вставка элемента в отсортированную часть массива. 
На самом деле это непросто и на какие только ухищрения не приходится идти, чтобы выполнить этот шаг.

Проходим по массиву слева направо и обрабатываем по очереди каждый элемент. 
Слева от очередного элемента наращиваем отсортированную часть массива, 
справа по мере процесса потихоньку испаряется неотсортированная. 
В отсортированной части массива ищется точка вставки для очередного элемента. 
Сам элемент отправляется в буфер, в результате чего в массиве появляется свободная ячейка — 
это позволяет сдвинуть элементы и освободить точку вставки.

data = [random.randint(1, 99) for i in range(100)]

def insertion(data):
    for i in range(len(data)):
        j = i - 1
        key = data[i]
        while data[j] > key and j >= 0:
            data[j + 1] = data[j]
            j -= 1
        data[j + 1] = key
    return data
    
    
argparse - это модуль для обработки аргументов командной строки. Примеры того, что позволяет делать модуль:

создавать аргументы и опции, с которыми может вызываться скрипт
указывать типы аргументов, значения по умолчанию
указывать, какие действия соответствуют аргументам
выполнять вызов функции при указании аргумента
отображать сообщения с подсказками по использованию скрипта

import subprocess
import argparse


def ping_ip(ip_address, count):
    reply = subprocess.run(
        f"ping -c {count} -n {ip_address}",
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        encoding="utf-8",
    )
    if reply.returncode == 0:
        return True, reply.stdout
    else:
        return False, reply.stdout + reply.stderr


parser = argparse.ArgumentParser(description="Ping script")

parser.add_argument("-a", dest="ip", required=True)
parser.add_argument("-c", dest="count", default=2, type=int)

args = parser.parse_args()
add_parser.set_defaults(func=ping_ip)
"""


# def parse_args():
#     import argparse
#
#     parser = argparse.ArgumentParser()
#     parser.add_argument("square", type=int,
#                         help="display a square of a given number")
#     parser.add_argument("-v", "--verbose", action="store_true",
#                         help="increase output verbosity")
#     parser.add_argument("-n", action="store", help='Variable n')
#     parser.add_argument("-l", action="append", help='List')
#     parser.add_argument("--const", action="store_const", const=5, help='List')
#     return parser.parse_args()
#
#
# if __name__ == "__main__":
#     params = parse_args()
#     print(params)
#     # breakpoint()
#     answer = params.square ** 2
#     if params.verbose:
#         print("the square of {} equals {}".format(params.square, answer))
#     else:
#         print(answer)


    # import argparse
    #
    # def parent():
    #     parent_parser = argparse.ArgumentParser(add_help=False)
    #     parent_parser.add_argument('--user', action="store")
    #     parent_parser.add_argument('--password', action="store")
    #     return parent_parser
    #
    # def child(parent_parser):
    #     child_parser = argparse.ArgumentParser(parents=[parent_parser])
    #     child_parser.add_argument('--show_all', action="store_true")
    #     return child_parser
    #
    # p = parent()
    # args = p.parse_args()
    # if args.user == 'super':
    #     c = child(p)
    #     args = c.parse_args()
    #
    # print(args)
